## xacro processing

xacro is a macro processor and you can pass parameteres to  for conditional processing.
For example:
```bash
cat <<EOF >/tmp/foo.xacro
<?xml version="1.0"?>
<robot xmlns:xacro="http://ros.org/wiki/xacro" name="foo">
<xacro:arg name="use_ros2_control" default="false" />
<xacro:if value="\$(arg use_ros2_control)">
  <say_something msg="ros2_control is being used"/>
</xacro:if>
<xacro:unless value="\$(arg use_ros2_control)">
  <say_something msg="ros2_control is not being used"/>
</xacro:unless>
</robot>
EOF
xacro /tmp/foo.xacro use_ros2_control:=true
```

If you run this in a bash terminal window, the output will be:
```code
<?xml version="1.0" ?>
<!-- =================================================================================== -->
<!-- |    This document was autogenerated by xacro from /tmp/foo.xacro                 | -->
<!-- |    EDITING THIS FILE BY HAND IS NOT RECOMMENDED                                 | -->
<!-- =================================================================================== -->
<robot name="foo">
  <say_something msg="ros2_control is being used"/>
</robot>
```

And if you run it with `false` as the argument on the `xacro` line, the output will be:
```code
<?xml version="1.0" ?>
<!-- =================================================================================== -->
<!-- |    This document was autogenerated by xacro from /tmp/foo.xacro                 | -->
<!-- |    EDITING THIS FILE BY HAND IS NOT RECOMMENDED                                 | -->
<!-- =================================================================================== -->
<robot name="foo">
  <say_something msg="ros2_control is not being used"/>
</robot>
```

So, you have a method to generate URDF files that include elements that are customized in various ways, especially if your robot wants to use ROS2 Control when running under gazebo simulation but uses your own motor driver that is not ros2_control based when not running under gazebo.

Here is a fragment of the `sigyn.urdf.xacro` file that I use for my Sigyn robot:
```code
<?xml version="1.0"?>
<robot xmlns:xacro="http://ros.org/wiki/xacro" name="Sigyn">
  <xacro:arg name="use_ros2_control" default="true" />
  <xacro:arg name="sim_mode" default="false" />
  <xacro:if value="$(arg use_ros2_control)">
    <xacro:include filename="ros2_control.xacro" />
  </xacro:if>
  ...
</robot>
```

And here is my `ros2_contro.xacro` file:

```code
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">

  <xacro:unless value="$(arg sim_mode)">
    <ros2_control name="endgripper_servo" type="actuator">
      <hardware>
        <plugin>pi_servo1/EndGripperJoint</plugin>
        <param name="example_param_hw_start_duration_sec">2.0</param>
        <param name="example_param_hw_stop_duration_sec">3.0</param>
        <param name="example_param_hw_slowdown">1.23</param>
      </hardware>
      <joint name="parallel_gripper_base_plate_to_left_finger">
        <command_interface name="position">
          <param name="min">-100</param>
          <param name="max">100</param>
        </command_interface>
        <state_interface name="position"/>
      </joint>
    </ros2_control>
  </xacro:unless>

  <xacro:if value="$(arg sim_mode)">
    <ros2_control name="GazeboSystem" type="system">
      <hardware>
        <plugin>gz_ros2_control/GazeboSimSystem</plugin>
      </hardware>
      <joint name="left_wheel_joint">
        <command_interface name="velocity">
          <param name="min">-10</param>
          <param name="max">10</param>
        </command_interface>
        <state_interface name="velocity" />
        <state_interface name="position" />
      </joint>
      <joint name="right_wheel_joint">
        <command_interface name="velocity">
          <param name="min">-10</param>
          <param name="max">10</param>
        </command_interface>
        <state_interface name="velocity" />
        <state_interface name="position" />
      </joint>

      <joint name="elevator_pole_to_elevator_connector_plate">
        <command_interface name="position">
          <param name="min">-100</param>
          <param name="max">100</param>
        </command_interface>
        <state_interface name="position"/>
      </joint>

      <joint name="gripper_elevator_plate_to_gripper_extender">
        <command_interface name="position">
          <param name="min">-100</param>
          <param name="max">100</param>
          <!-- <param name="min">0</param>
          <param name="max">0.4</param> -->
        </command_interface>
        <state_interface name="position"/>
      </joint>

      <joint name="gripper_wrist_to_parallel_gripper_base_plate">
        <command_interface name="position">
          <param name="min">-100</param>
          <param name="max">100</param>
        </command_interface>
        <state_interface name="position"/>
      </joint>

      <joint name="parallel_gripper_base_plate_to_left_finger">
        <command_interface name="position">
          <param name="min">-100</param>
          <param name="max">100</param>
        </command_interface>
        <state_interface name="position"/>
      </joint>

      <!-- <joint name="parallel_gripper_base_plate_to_right_finger">
        <state_interface name="position"/>
      </joint> -->

    </ros2_control>
  </xacro:if>

  <gazebo>
    <plugin name="gz_ros2_control::GazeboSimROS2ControlPlugin" filename="libgz_ros2_control-system.so">
      <parameters>$(find description)/config/my_controllers.yaml</parameters>
      <parameters>$(find description)/config/gaz_ros2_ctl_use_sim.yaml</parameters>
    </plugin>
  </gazebo>

</robot>
```

The takeaways from this are:

* When I'm not running a gazebo simulation (i..e., sim_mode is `false`), my URDF contains a `ros2_control` section for my `endgripper_servo` component, which is a custom ros2_control hardware driver I wrote as part of the robot's gripper hardware I created, but I do not use ros2_control to run my motors. I use the RoboClaw driver that I wrote which itself reads the `cmd_vel` commands comming from the nav2 stack or the joystick/keyboard teleop (which is all mediated by a twist multiplexor node) and generates the appropriate motor signals.

* When I'm running a gazebo simulation (i..e., sim_mode is `true`), my URDF contains a `gazebo` section for my `GazeboSystem` component since the gazebo simulator provides, conveniently, a ros2_control plugin that will itself listen to the `cmd_vel` commands and simulate moving the two wheel joints. In my case, it also use gazebo to simulate my gripper joints in the URDF as well.

Outside of the conditional URDF statements, I have a `gazebo` element that names the `GazeboSimROS2ControlPlugin` plugin, which is a bit of C++ code provided by the gazebo group that interprets the URDF elements so that actual motor simulation will happen. As it's wrapped in a `gazebo` element, it's okay to always include it in the URDF as when you are not running under the gazebo simulator, all of the `gazebo` elements are ignored. I suppose I could have put the last `gazebo` element inside the conditional block that is only processed when `sim_mode` is true, but I didn't.


